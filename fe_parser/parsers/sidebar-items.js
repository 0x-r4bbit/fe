initSidebarItems({"enum":[["Tail",""]],"fn":[["arg_def",""],["arg_list",""],["args",""],["arr_dim","Parse an array dimension e.g. \"[2]\""],["arr_list","Parse an array dimension list e.g. \"[2][3]\""],["assert_stmt",""],["assign_stmt",""],["atom",""],["attr_tail",""],["augassign_stmt",""],["base_type","Parse a base type along with an optional array dimension list."],["bin_op_builder",""],["bitwise_and",""],["bitwise_or",""],["bitwise_xor",""],["block",""],["bool_op_builder",""],["break_stmt",""],["build_tail_expr",""],["call_tail",""],["comp_op",""],["comp_op_builder",""],["comparison",""],["compound_stmt",""],["conjunct",""],["continue_stmt",""],["contract_def","Parse a contract definition statement."],["contract_field","Parse a contract field definition."],["contract_field_qual","Parse a contract field qualifier keyword e.g. \"const\"."],["contract_stmt","Parse a contract statement."],["dedent_token","Parse a dedent token."],["disjunct",""],["dots_to_int","Parse preceding dots used to indicate parent module imports in import statements."],["dotted_name","Parse a dotted import name."],["elif_stmt",""],["else_block",""],["emit_stmt",""],["empty_file_input","Parse an empty module definition."],["endmarker_token","Parse an endmarker token."],["event_def","Parse an event definition statement."],["event_field","Parse an event field definition."],["event_field_qual","Parse an event field qualifier keyword i.e. \"idx\"."],["expr",""],["exprs","Parse a comma-separated list of expressions."],["factor",""],["file_input","Parse a module definition."],["for_stmt",""],["from_import","Parse an import statement beginning with the \"from\" keyword."],["from_import_name","Parse an import name with an optional alias in a \"from\" import statement."],["from_import_names","Parse the names to be imported by a \"from\" import statement."],["from_import_names_list","Parse a list of names to be imported by a \"from\" import statement."],["from_import_names_parens","Parse a parenthesized list of names to be imported by a \"from\" import statement."],["from_import_names_star","Parse a wildcard token (\"*\") in a \"from\" import statement."],["from_import_parent_alt","Parse a \"from\" import with a path that contains only parent module components."],["from_import_sub_alt","Parse a \"from\" import with a path that contains sub module components."],["from_import_sub_path","Parse a path containing sub module components in a \"from\" import statement."],["func_def",""],["func_qual","Parse a function qualifier keyword i.e. \"pub\"."],["func_stmt",""],["group",""],["if_stmt",""],["if_stmt_builder",""],["import_stmt","Parse an import statement."],["indent_token","Parse an indent token."],["index_tail",""],["keyword_statement",""],["kwarg",""],["kwargs",""],["list",""],["map_type","Parse a map type e.g. \"map<address, bool\"."],["map_type_double","Parse a map type ending with a right-shift token."],["map_type_single","Parse a map type ending with a greater-than token."],["module_stmt","Parse a module statement, such as a contract definition."],["name","Parse a name token containing a specific string."],["name_token","Parse a name token."],["newline_token","Parse a grammatically significant newline token."],["next","Parse next token in input."],["non_empty_file_input","Parse a non-empty module definition."],["number_token","Parse a number token."],["op","Parse an op token containing a specific string."],["op_token","Parse an op token."],["pass_stmt",""],["power",""],["primary",""],["return_stmt",""],["revert_stmt",""],["shift_expr",""],["simple_import","Parse an import statement beginning with the \"import\" keyword."],["simple_import_name",""],["simple_stmt",""],["slice",""],["slices",""],["small_stmt",""],["string_token","Parse a string token."],["sum",""],["t_atom",""],["t_tail",""],["target",""],["targets",""],["term",""],["token","Parse a token of a specific type."],["try_from_tok",""],["tuple",""],["type_def","Parse a type definition (type alias)."],["type_desc","Parse a type description e.g. \"u256\" or \"map<address, bool>\"."],["unary_op_builder",""],["vardecl_stmt",""],["while_stmt",""]]});